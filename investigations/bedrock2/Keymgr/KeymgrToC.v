Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import bedrock2.Syntax.
Require Import bedrock2.ToCString.
Require Import bedrock2.Variables.
Require Import coqutil.Z.HexNotation.
Require Import Bedrock2Experiments.Keymgr.Keymgr.
Require Import Bedrock2Experiments.LibBase.Bitfield.
Import ListNotations.
Local Open Scope string_scope.
Local Open Scope Z_scope.

Definition dquote : string := String (Ascii.ascii_of_nat 34) EmptyString.
Definition keymgr_c_template_top : string :=
  "// Autogenerated from Coq based on LowRISC implementation

// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include ""sw/device/silicon_creator/lib/drivers/keymgr.h""

#include ""sw/device/silicon_creator/lib/base/abs_mmio.h""

#include ""hw/top_earlgrey/sw/autogen/top_earlgrey.h""
#include ""keymgr_regs.h""  // Generated.

enum {
  kBase = TOP_EARLGREY_KEYMGR_BASE_ADDR,
};".

Definition keymgr_c_template_bottom : string :=
  "static rom_error_t check_expected_state(uint32_t expected_state,
                                      uint32_t expected_status) {
  return b2_check_expected_state((uintptr_t) expected_state,
                                 (uintptr_t) expected_status);
}

static void advance_state(void) {
  b2_advance_state();
}

rom_error_t keymgr_init(uint16_t entropy_reseed_interval) {
  return b2_keymgr_init((uintptr_t) entropy_reseed_interval);
}

rom_error_t keymgr_state_creator_check() {
  return b2_keymgr_state_creator_check();
}

rom_error_t keymgr_state_advance_to_creator(const uint32_t binding_value[8],
                                            uint32_t max_key_ver) {
  RETURN_IF_ERROR(
      check_expected_state(KEYMGR_WORKING_STATE_STATE_VALUE_INIT,
                           KEYMGR_OP_STATUS_STATUS_VALUE_DONE_SUCCESS));

  // Write and lock (rw0c) the software binding value. This register is unlocked
  // by hardware upon a successful state transition.
  // FIXME: Consider using sec_mmio module for the following register writes.
  for (size_t i = 0; i < 8; ++i) {
    abs_mmio_write32(
        kBase + KEYMGR_SW_BINDING_0_REG_OFFSET + i * sizeof(uint32_t),
        binding_value[i]);
  }
  abs_mmio_write32(kBase + KEYMGR_SW_BINDING_REGWEN_REG_OFFSET, 0);

  // Write and lock (rw0c) the max key version.
  abs_mmio_write32(kBase + KEYMGR_MAX_CREATOR_KEY_VER_REG_OFFSET, max_key_ver);
  abs_mmio_write32(kBase + KEYMGR_MAX_CREATOR_KEY_VER_REGWEN_REG_OFFSET, 0);

  // Advance to CREATOR_ROOT_KEY state.
  advance_state();
  return kErrorOk;
}".

Definition funcs := [
  bitfield_field32_write
  ;bitfield_field32_read
  ;bitfield_bit32_write
  ;check_expected_state
  ;advance_state
  ;keymgr_init
  ;keymgr_state_creator_check
  ].

Definition make_keymgr_c :=
  keymgr_c_template_top ++
  concat LF (map (fun f => "static " ++ c_func f) funcs) ++
  keymgr_c_template_bottom.

Require Import bedrock2.Bytedump.
Local Open Scope bytedump_scope.
Goal True.
  (* Note: run using make/coqc to avoid IDE bugs causing missing newlines or spurious <infomsg>*)
  Redirect "keymgr.c"
    let c_code := eval compute in (byte_list_of_string make_keymgr_c) in idtac c_code.
Abort.
